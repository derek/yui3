<h1>Dissecting 3.5.0 DataTable</h1>

<style>
.before, .after { width: 47%; }
.after {
    margin-left: 5%;
}
</style>
<p>
    DataTable has been one of YUI's most heavily used and relied upon widgets
    for years.  Even today, YUI 3 adoption has been slower than it might be
    because this-or-that feature from YUI 2 DataTable hasn't been ported to 3
    yet.  And if you know YUI 2 DataTable, you know there are a <em>lot</em> of
    features to port to 3.
</p>

<p>
    In 3.5.0, DataTable got a major overhaul, and as a result it is 
    looking a little different and <strong>working a lot better</strong>.  But
    most importantly, it is now architecturally structured to make it easy to
    fill in those missing features rapidly, and with greater confidence that
    the supporting infrastructure won't break down when new features are added
    and the limitless combinations and per-implementation customizations appear
    in the wild.
</p>

<p>
    In this two part series, we'll first talk about the big changes in 3.5.0
    DataTable and what led up to the decision to revisit the infrastructure
    rather than focus on adding features.  Then in the next article, we'll break
    down some of the new concepts being explored by the revised DataTable,
    including a few experimental changes, and finish up with a look at the plan
    for 3.6.0 and the future as we see it today.
</p>

<p>
    So without further ado, let's address the obvious question:
</p>

<h2>Why Refactor?</h2>

<p>
    The short answer is "to make it easier and more customizable".  The 3.4.1
    infrastructure was based on the simple Widget model, where all the code to
    describe the state and render the UI were in one place, and altering or
    expanding those core behaviors was the responsibility of plugins.  That's a
    fine architecture for some Widgets, but there are a few issues with this
    for DataTable:
</p>

<ol>
    <li>
        To a fair extent, DataTables are defined by their features, which means
        there could be a lot of `plug()`ing to get the DataTable that fits your
        application.  This made getting started with DataTable more
        complicated, and working with DataTable more verbose.
    </li>
    <li>
        DataTable is composed of multiple parts, and features often need to
        interact with more than one of these parts to work.  This is a difficult
        situation to navigate as the feature list grows, and the constraint of
        the plugin contract made this more difficult.  In fact, this contract
        was already broken in 3.4.1, and in ways that signaled that it was
        untenable for upcoming features.
    </li>
    <li>
        Some features need (or needed) to impact parts of the base
        implementation so dramatically, that it suggested a better approach
        would be to allow for more configuration in those areas in the core or
        create a subclass.  But features-through-inheritance opens its own can
        of worms, and configuration overload makes the API larger and more
        difficult to understand.
    </li>
</ol>

<p>
    The new architecture aims to address these and other issues uncovered
    during its production life prior to 3.5.0, and take advantage of the
    excellent work in the App framework components that weren't around when
    DataTable debuted in 3.3.0.
</p>

<p>
    DataTable is incredibly important to a lot of people, and it's important
    to us that it not only be built right, but also that it be <em>as easy to
    use as possible</em>.
</p>

<h2>Big Changes</h2>

<p>
    The major changes from 3.4.1 to 3.5.0 are mostly under the hood, and with
    any luck,
    <a href="http://yuilibrary.com/yui/docs/datatable/migration.html">migrating
    to 3.5.0 DataTable</a> should be painless.
</p>

<p>
    That said, there are some obvious, outward changes to the API and how you
    add (or don't need to explicitly add) features.  Take for example, creating
    a sortable DataTable.
</p>

<div class="yui3-g">
    <div class="yui3-u before">
        <h4 class="no-toc">3.4.1</h4>

        ```
        // Assumes use('datatable-sort') or use('datatable')
        var table = new Y.DataTable.Base({
            columnset: [
                { key: "id" },
                { key: "name", sortable: true },
                { key: "price", sortable: true }
            ],
            recordset: [
                { id: 1, name: "Bread", price: 3.45 },
                { id: 2, name: "Milk",  price: 4.99 },
                { id: 3, name: "Eggs",  price: 2.75 },
                ...
            ]
        });

        table.plug(Y.Plugin.DataTableSort);

        table.render('#back-then');

        // Sorting API is on the Recordset's plugin
        table.get("recordset").sort.sort("name");
        ```
    </div>
    <div class="yui3-u after">
        <h4 class="no-toc">3.5.0</h4>

        ```
        // Constructor is now Y.DataTable
        var table = new Y.DataTable({
            // columns takes the place of columnset
            columns: [
                { key: "id" },
                { key: "name", sortable: true },
                { key: "price", sortable: true }
            ],
            // data takes the place of recordset
            data: [
                { id: 1, name: "Bread", price: 3.45 },
                { id: 2, name: "Milk",  price: 4.99 },
                { id: 3, name: "Eggs",  price: 2.75 },
                ...
            ]
        });

        // Plugin NOT needed. Sorting enabled by datatable-sort

        table.render('#here-and-now');

        // APIs are centralized on the instance now
        table.sort("name");
        ```
    </div>
</div>

<h3>What's in a Name?</h3>

<p>
    The first thing you'll notice is that as of 3.5.0, `Y.DataTable` is the
    main instantiable class.  `Y.DatatTable.Base` is still around, but now its
    primary role is as a superclass for extension (which we'll talk more about
    in the next article).
</p>

```
// 3.4.1
var before = new Y.DataTable.Base({ ... });

// 3.5.0
var after = new Y.DataTable({ ... });
```

<p>
    `Y.DataTable` continues to serve the role of namespace as well, and now
    you'll find all the classes that support or enhance DataTable here, such
    as `Y.DataTable.Base`, `Y.DataTable.Sortable`, and `Y.DataTable.BodyView`.
    The notable exception is `Y.Plugin.DataTableDataSource`, which hasn't yet
    been migrated over to the new world order (expect that in 3.6.0).
</p>

<p>
    You'll see more about this in the next article as well, when we talk about
    some of DataTable's new concepts.
</p>

<h3>Features as Class Extensions</h3>

<p>
    The 3.5.0 architecture marks a shift <em>away</em> from the plugin model
    for DataTable.  Instead, we're putting features in class extensions, and
    using the powerful
    <a href="http://yuilibrary.com/yui/docs/api/classes/Base.html#method_mix">`Y.Base.mix()`</a>
    method to augment these features into the DataTable class, creating a sort
    of ad-hoc multiple inheritance model.
</p>

<p>
    The two primary benefits this approach has are:
</p>

<ol>
    <li>
        The API for your DataTable and all its features is in one place, your
        `Y.DataTable` instance.
    </li>
    <li>
        Rather than having to explicitly build up your DataTable from the Base,
        simply including the feature modules in your `use()` line adds support
        for those features to the the `Y.DataTable` class.
    </li>
</ol>

<p>
    But what if you have a couple DataTables on the page, and you don't want
    all of them sortable or scrollable, etc.?
</p>

<p>
    To keep features from leaking between DataTable instances, each feature
    includes a behavioral trigger, which is responsible for activating the
    feature for that particular instance.  Usually the trigger is a
    configuration attribute, such as "scrollable", but it might also look for a
    trigger in your column configurations such as "sortable" or "width".
</p>

```
// By including feature modules, Y.DataTable can use the features
YUI().use('datatable-sort', 'datatable-scroll', function (Y) {

var table = new Y.DataTable({
    data: ...,

    columns: [
        // column.sortable is one way to trigger
        // the ability to sort by header cell clicks
        { key: 'partnum', label: 'Part #', sortable: true },
        { key: 'desc', label: 'Part', sortable: true },
        { key: 'cost', label: 'Cost' }
    ],

    // vertical scrolling rows activated by setting scrollable and height
    scrollable: 'y',
    height: '350px'
}).render('#here-and-now');

});
```

<h3>Now With More MVC!</h3>

<p>
    DataTable resembles a small app more than a simple Widget. It manages
    collections of data, column and instance configurations, renders distinctly
    different content into multiple areas (including the `<table>`,
    `<thead>`, and `<tbody>`, to name the most obvious), and is responsible for
    keeping all of these pieces in sync.  And adding features only increases
    the list of moving parts.
</p>

<p>
    So it seemed appropriate that DataTable should use the App framework
    components since that's what they're for.  In 3.5.0, DataTable now
    uses Model, ModelList, and View to manage its data and rendering needs.
    Recordset and Record are still supported components, separate from
    DataTable in 3.5.0, but may be deprecated in the future so we can focus on
    a single family of components for data representation in YUI.
</p>

<h4>Models for Data</h4>

<p>
    There are a lot of benefits to using Model and ModelList for DataTable's
    record storage, the most compelling reasons being:
</p>

<ul>
    <li>
        the App framework is very popular, which means its progress and feature
        list can immediately benefit DataTable users
    </li>
    <li>
        being able to create custom Models to represent your business objects
        and reuse them across components makes for a more stable codebase
    </li>
    <li>
        familiar APIs between components makes the library as a whole easier
        to use
    </li>
</ul>

<p>
    Now if you have a table record in hand, it is a Model instance, and you
    access and update its fields using the Attribute API:
</p>

```
// 3.4.1
record.getValue('username');
record.get('data').favColor = '#C0FFEE';

// 3.5.0
model.get('username');
model.set('favColor', '#C0FFEE');
```

<p>
    In most use cases, the change to Model and ModelList will be transparent
    since passing an array of columns and an array of objects for data to the
    DataTable constructor will still result in the same rendered table.
    However, when you start needing more intelligence from the objects the
    table is displaying, Model is perfectly positioned as a superclass for your
    business objects.
</p>

<p>
    To keep things simple, DataTable will create a Model subclass for you
    based on your data, but if you want to use your own Model class for your
    table records, DataTable now has a `recordType` attribute which will accept
    any of:
</p>

<ul>
    <li>a Model subclass (or class that quacks like a Model)</li>
    <li>
        an array of Model attribute names&mdash;similar to `columns`, but
        controls what data is stored; `columns` controls what is displayed
    </li>
    <li>
        an object corresponding to an ATTRS definition object, where you can
        <a href="datatable-recordtype.html">specify field validators, setters,
        getters, default values, etc.</a>.
    </li>
</ul>

<p>
    Alternately, you can just pass a prebuilt ModelList instance for the
    DataTable's `data` attribute, configured with whatever Model is appropriate.
</p>

<p>
    
    This new configuration option decouples DataTable from the data
    implementation, providing more opportunity for customization.
    For example, if you don't need any mutation events or attribute fanciness
    from your records&mdash;you just want it to render as fast as
    possible&mdash;you can configure it with a `recordType` class that pretends
    to be a Model, but is actually a much simpler object.
</p>

```
// Warning: crazy hack that probably shouldn't ever be used
// Some quacking will be needed for the various places where duck-typing is used
function DumbRecord(data) {
    this.data = data;
    this._id = 'record_' + DumbRecord._id++;
    this.lists = []; // quack
}

DumbRecord._id = 0;
DumbRecord.prototype = {
    _isYUIModel: 'quack',
    set: function () { /* quack */ },
    addTarget: function () { /* quack */ },
    getAttrs: function () { /* quack */ },

    get: function (name) {
        return name === 'clientId' ? this._id : this.data[name];
    },
    toJSON: function () { return this.data },
};

var table = new Y.DataTable({
    columns: [ ... ],
    data:  [ ... ],
    recordType: DumbRecord
}).render('#over-there');
```

<p>
    <strong>Note</strong>: This is an extreme case, and a hack, and shouldn't
    be necessary.  `recordType` is best used to build _on top of_ Model's
    infrastructure with classes that model your business objects.  There are
    several performance improvements planned for 3.6.0, making such hackery
    unnecessary even in those extreme cases.
</p>

<h4>Views for Rendering</h4>

<p>
    In keeping with the notion of configurable data storage, DataTable similarly
    delegates its rendering algorithms to View classes.  In 3.5.0, the basic,
    featureless DataTable has attributes `headerView`, `bodyView`, and
    `footerView`.  By default, `footerView` is unset, but `headerView` is set
    to `Y.DataTable.HeaderView`, and `bodyView` is set to
    `Y.DataTable.BodyView`.
</p>

<p>
    When a DataTable instance is `render()`ed, the only DOM content the Widget
    itself is responsible for is the `<table>` and its immediate children.  The
    rendering of the header content, footer content, and data rows is left to
    whatever View class is supplied to the respective attribute.
</p>

<p>
    The default Views attempt to match, and augment, the 3.4.1 feature set for
    header and cell customization, but with faster rendering algorithms.
    However, with the View itself now being configurable, that means that you
    can customize DataTable rendering from the column configuration level all
    the way to the View level, replacing the algorithm entirely.
</p>

```
// Create a custom subclass of View with a very simple rendering algorithm
var RowRowRowYourView = Y.Base.create('tableBody', Y.View, [], {
    render: function () {
        var tbody   = this.get('container'),
            rowData = this.get('modelList'),
            content = '';

        rowData.each(function (rowModel, index) {
            var stripe = index % 2 ? 'odd' : 'even',
                template = '<tr class="' + (index % 2 ? 'odd' : 'even') + '">' +
                    '<td>{username}</td><td>{first}</td><td>{last}</td>' +
                '</tr>';

            content += Y.Lang.sub(template, rowModel.toJSON());
        });

        tbody.setHTML(content);

        return this;
    }
});

var table = new Y.DataTable({
    data: [ ... ],
    columns: [ ... ],
    bodyView: RowRowRowYourView
}).render('#over-there');
```

<h3>New Rendering Algorithm</h3>

<p>
    The last thing we'll cover in this article is DataTable's new, faster,
    default rendering technique.
</p>

<p>
    In 3.4.1 and prior, the rendering process relied heavily on the Node API.
    Populating cells and rows was done by creating a Node instance for each
    element and assembling them with the Nodes' DOM methods.  This approach
    has two big disadvantages:
</p>

<ol>
    <li>
        Nodes are stored in an object cache so that future reference to the
        same element will point to the same Node instance.  However, in nearly
        all cases, the table elements weren't useful beyond their role in
        rendering the table, so a fair bit of memory wound up getting reserved
        for the life of the application unnecessarily.
    </li>
    <li>
        Nodes are light weight objects, but they're not free.  Creating a Node
        instance for each row, cell, and liner `<div>` in larger tables made
        for a lot of new objects.  Also, while Node's DOM methods efficiently
        proxy through to the native DOM method, they still need to preserve the
        Node abstraction layer for return values.  So all those DOM methods
        incurred the usual cost of DOM manipulation, plus some function
        wrapping overhead.
    </li>
</ol>

<p>
    The way DataTable avoids this in 3.5.0 is by using HTML string
    concatenation as much as possible.  The default View for rendering the
    `<tbody>` rows creates a row template with substitution `{placeholder}`s
    for the cell values and a few other things.  It then iterates over the
    `data` ModelList items, calls any column `formatter`s with that row's Model
    data, and appends a single HTML string with the row template string after
    substituting the `{placeholder}` values.
</p>

<p>
    The final string is then inserted into the `<tbody>` in a single DOM
    operation, without creating any Node instances at all.  The resulting
    performance looks like this:
</p>

<style>
    #charts {
        height: 250px;
    }
    #perf-chrome, #perf-ff, #perf-ie {
        margin: 0 1em;
        height: 200px;
    }
</style>
<div class="yui3-g" style="height: 250px;">
    <div class="yui3-u-1-3">
        <h5>Chrome 18</h5>
        <div id="perf-chrome"></div>
    </div>
    <div class="yui3-u-1-3">
        <h5>Firefox 11</h5>
        <div id="perf-ff"></div>
    </div>
    <div class="yui3-u-1-3">
        <h5>IE 8</h5>
        <div id="perf-ie"></div>
    </div>
</div>
<script>
YUI({ filter: 'raw' }).use('charts', function (Y) {

    new Y.Chart({
        categoryKey: 'rows',
        axes: {
            rows: {
                keys: ['rows'],
                title: "Table Rows"
            },
            values: {
                title: 'Render time (ms)'
            }
        },
        dataProvider: [
            { rows: 10, "2.9.0": 5, "3.4.0": 43, "3.5.0": 13 },
            { rows: 20, "2.9.0": 9, "3.4.0": 53, "3.5.0": 20 },
            { rows: 50, "2.9.0": 13, "3.4.0": 71, "3.5.0": 30 },
            { rows: 100, "2.9.0": 21, "3.4.0": 128, "3.5.0": 49 }
        ]
    }).render('#perf-chrome');

    new Y.Chart({
        categoryKey: 'rows',
        axes: {
            rows: {
                keys: ['rows'],
                title: "Table Rows"
            },
            values: {
                title: 'Render time (ms)'
            }
        },
        dataProvider: [
            { rows: 10, "2.9.0": 16.4, "3.4.0": 65.6, "3.5.0": 22.3 },
            { rows: 20, "2.9.0": 21.8, "3.4.0": 80.6, "3.5.0": 21.8 },
            { rows: 50, "2.9.0": 32, "3.4.0": 120.6, "3.5.0": 44 },
            { rows: 100, "2.9.0": 41.5, "3.4.0": 183.3, "3.5.0": 51.2 }
        ]
    }).render('#perf-ff');

    new Y.Chart({
        categoryKey: 'rows',
        axes: {
            rows: {
                keys: ['rows'],
                title: "Table Rows"
            },
            values: {
                title: 'Render time (ms)'
            }
        },
        dataProvider: [
            { rows: 10, "2.9.0": 22, "3.4.0": 91, "3.5.0": 25 },
            { rows: 20, "2.9.0": 32, "3.4.0": 146, "3.5.0": 42 },
            { rows: 50, "2.9.0": 68, "3.4.0": 315, "3.5.0": 78 },
            { rows: 100, "2.9.0": 135, "3.4.0": 621, "3.5.0": 132 }
        ]
    }).render('#perf-ie');

});
</script>

<h4>But what if you need access to the cell Node for some reason?</h4>

<p>
</p>

Rendering events
    render vs renderTable vs renderHeader, etc
    event to hand off responsibility to View


<h2>New Concepts</h2>

    MVC (really MVP) Widget

    Controller/View-Controller
        primary API lives on the instance
        some methods will relay to the view

    Instantiable namespace, pristeen Base
    Extensions auto-mixed

<h3>New Feature Architecture</h3>

<p>
    The downside of the name changes noted above is that the plugins that were
    reimplemented as class extensions suddenly disappear from the `Y.Plugin`
    namespace.  This can be confusing because `plug()` doesn't throw an error
    when a non-existent plugin class is passed as an argument.  But if your code
    is creating an instance of `Y.DataTable.Base` and plugging in
    `Y.Plugin.DataTableSort`, as of 3.5.0 it won't be sortable because the
    plugin doesn't exist, and sorting is added to `Y.DataTable`, not
    `Y.DataTable.Base`.  However, the fix is easy: change `Y.DataTable.Base` to
    `Y.DataTable`.  And you can get rid of the superfluous call to `plug(...)`
    as well.
</p>

<div class="yui3-g">
    <div class="yui3-u before">
        <h4 class="no-toc">Creates a non-sortable table in 3.5.0</h4>

        ```
        // DataTable.Base has no features, and ...
        var table = new Y.DataTable.Base({
            columns: [
                { key: "id" },
                { key: "name", sortable: true },
                { key: "price", sortable: true }
            ],
            data: [ ... ]
        });

        // the feature plugin no longer exists
        table.plug(Y.Plugin.DataTableSort);

        table.render('#back-then');
        ```
    </div>
    <div class="yui3-u after">
        <h4 class="no-toc">Fixed</h4>

        ```
        // Sorting is added to Y.DataTable by datatable-sort
        var table = new Y.DataTable({
            columns: [
                { key: "id" },
                { key: "name", sortable: true },
                { key: "price", sortable: true }
            ],
            data: [ ... ]
        });

        // now does nothing, but is harmless
        table.plug(Y.Plugin.DataTableSort);

        table.render('#here-and-now');
        ```
    </div>
</div>


<h2>New Features</h2>
mutable + sync layer access
column widths
100% width scrolling
table initially sorted
multi-column sorting
custom column sorting works
sortable: true/array
formatter rowClass
nodeFormatter
footer support


<h2>Experiments</h2>

Columns are simple objects
    removes the notion of a column instance, making changes to columns rely on
        table APIs
    In response to separation of concerns issues where a feature (sorting)
        required the Column class to host additional attributes.  A plugin
        requiring a class extension is confusing.
    May have been obviated by adhoc attribute support, added in 3.5.0 after
        the change was already in place.

Extensions auto-mixed


<h2>The way forward</h2>

gallery-preview module
view (aka tableView)
clean up/improve the configuration of Views
migrating features to new contract extension + view implementation model
pagination
progressive enhancement
cell/row editing
highlighting
row/cell selection
remote data love


<h3>When Will it Be Out of Beta?</h3>
Complicates beta marking because components are marked beta, not features

<h3>Questions?</h3>

forums, #yui, @ls_n. Shout out to the dialog in these places driving/validating
API decisions and helping prioritize the order of current and future feature
implementation.

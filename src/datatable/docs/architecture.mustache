<h1>Dissecting 3.5.0 DataTable</h1>

<style>
.before, .after { width: 47%; }
.after {
    margin-left: 5%;
}
</style>
<p>
    DataTable has been one of YUI's most heavily used and relied upon widgets
    for years.  Even today, YUI 3 adoption has been slower than it might be
    because this-or-that feature from YUI 2 DataTable hasn't been ported to 3
    yet.  And if you know YUI 2 DataTable, you know there are a <em>lot</em> of
    features to port to 3.
</p>

<p>
    In 3.5.0, DataTable got a major overhaul, and as a result it is 
    looking a little different and <strong>working a lot better</strong>.  But
    most importantly, it is now architecturally structured to make it easy to
    fill in those missing features rapidly, and with greater confidence that
    the supporting infrastructure won't break down when new features are added
    and the limitless combinations and per-implementation customizations appear
    in the wild.
</p>

<p>
    Before we get into the nitty gritty, I want to answer the obvious question:
</p>

<h2>Why Refactor?</h2>

<p>
    The short answer is "to make it easier".  The 3.4.1 infrastructure was based
    on the simple Widget model, where all the code to describe the state and
    render the UI were in one place, and altering or expanding those core
    behaviors was the responsibility of plugins.  That's a fine architecture for
    some Widgets, but there are a few issues with this for DataTable:
</p>

<ol>
    <li>
        To a fair extent, DataTables are defined by their features, which means
        there could be a lot of `plug()`ing to get the DataTable that fits your
        application.  This made getting started with DataTable more
        complicated, and working with DataTable more verbose.
    </li>
    <li>
        DataTable is composed of multiple parts, and features often need to
        interact with more than one of these parts to work.  This is a difficult
        situation to navigate as the feature list grows, and the constraint of
        the plugin contract made this more difficult.  In fact, this contract
        was already broken in 3.4.1, and in ways that signaled that it was
        untenable for upcoming features.
    </li>
    <li>
        Some features need or needed to impact parts of the base implementation
        so dramatically, that it suggested a better approach would be to allow
        for more configuration in those areas in the core.  But configuration
        has limits when implemented in a single place.  The code starts to
        become monolithic, which runs counter to the goals of YUI 3.
    </li>
</ol>

<p>
    The new architecture aims to address these and other issues uncovered
    during its production life prior to 3.5.0, and take advantage of the
    excellent work in the App framework components that weren't around when
    DataTable debuted in 3.3.0.
</p>

<p>
    DataTable is incredibly important to a lot of people, and it's important
    to us that it not only be built right, but also that it be as easy to use
    as possible.
</p>

<h2>Big Changes</h2>

<p>
    The major changes from 3.4.1 to 3.5.0 are mostly under the hood, and with
    any luck,
    <a href="http://yuilibrary.com/yui/docs/datatable/migration.html">migrating
    to 3.5.0 DataTable</a> should be painless.
</p>

<p>
    That said, there are some obvious, outward changes to the API and how you
    add (or don't need to explicitly add) features.  Take for example, creating
    a sortable DataTable.
</p>

<div class="yui3-g">
    <div class="yui3-u before">
        <h4 class="no-toc">3.4.1</h4>

        ```
        // Assumes use('datatable-sort') or use('datatable')
        var table = new Y.DataTable.Base({
            columnset: [
                { key: "id" },
                { key: "name", sortable: true },
                { key: "price", sortable: true }
            ],
            recordset: [
                { id: 1, name: "Bread", price: 3.45 },
                { id: 2, name: "Milk",  price: 4.99 },
                { id: 3, name: "Eggs",  price: 2.75 },
                ...
            ]
        });

        table.plug(Y.Plugin.DataTableSort);

        table.render('#back-then');

        // Sorting API is on the Recordset's plugin
        table.get("recordset").sort.sort("name");
        ```
    </div>
    <div class="yui3-u after">
        <h4 class="no-toc">3.5.0</h4>

        ```
        // Constructor is now Y.DataTable
        var table = new Y.DataTable({
            // columns takes the place of columnset
            columns: [
                { key: "id" },
                { key: "name", sortable: true },
                { key: "price", sortable: true }
            ],
            // data takes the place of recordset
            data: [
                { id: 1, name: "Bread", price: 3.45 },
                { id: 2, name: "Milk",  price: 4.99 },
                { id: 3, name: "Eggs",  price: 2.75 },
                ...
            ]
        });

        // Plugin NOT needed. Sorting enabled by datatable-sort

        table.render('#here-and-now');

        // APIs are centralized on the instance now
        table.sort("name");
        ```
    </div>
</div>

<h3>What's in a Name?</h3>

<p>
    The first thing you'll notice is that as of 3.5.0, `Y.DataTable` is the
    main instantiable class.  `Y.DatatTable.Base` is still around, but now its
    primary role is as <a href="#baseclass">a superclass for extension</a>.
</p>

```
// 3.4.1
var before = new Y.DataTable.Base({ ... });

// 3.5.0
var after = new Y.DataTable({ ... });
```

<p>
    `Y.DataTable` continues to serve the role of namespace as well, and now
    you'll find all the classes that support or enhance DataTable inside, such
    as `Y.DataTable.Base`, `Y.DataTable.Sortable`, and `Y.DataTable.BodyView`.
    The notable exception is `Y.Plugin.DataTableDataSource`, which hasn't yet
    been migrated over to the new world order (expect that in 3.6.0).
</p>

<p>
    You'll see more about this below, when we talk about some of the
    <a href="#newconcepts">new concepts</a> used in DataTable.
</p>

<h3>Now With More MVC!</h3>

<p>
    DataTable now uses the App framework components Model, ModelList, and View
    to manage its data and rendering needs.  Recordset and Record are still
    supported components separate from DataTable in 3.5.0, but may be
    deprecated in the future so we can focus on a single family of components
    for data representation in YUI.
</p>

<h4>Models for Data</h4>

<p>
    There are a lot of benefits to using Model and ModelList for DataTable's
    record storage, the most compelling reasons being:
</p>

<ul>
    <li>
        the App framework is very popular, which means its progress and feature
        list can immediately benefit DataTable users
    </li>
    <li>
        being able to create custom Models to represent your business objects
        and reuse them across components makes for a more stable codebase
    </li>
    <li>
        familiar APIs between components makes each an easy gateway to the
        others
    </li>
</ul>

<p>
    Now if you have a table record in hand, it is a Model instance, and you
    access and update its fields using the Attribute API:
</p>

```
// 3.4.1
record.getValue('username');
record.get('data').favColor = '#C0FFEE';

// 3.5.0
model.get('username');
model.set('favColor', '#C0FFEE');
```

<p>
    In most use cases, the change to Model and ModelList will be transparent
    since passing an array of columns and an array of objects for data to the
    DataTable constructor will still result in the same rendered table.
    However, when you start needing more intelligence from the objects the
    table is displaying, Model is perfectly positioned as a superclass for your
    business objects.
</p>

<p>
    To keep things simple, DataTable will create a Model subclass for you
    based on your data, but if you want to use your own Model class for your
    table records, DataTable now has a `recordType` attribute which will accept
    any of:
</p>

<ul>
    <li>a Model subclass (or class that quacks like a Model)</li>
    <li>
        an array of Model attribute names&mdash;similar to `columns`, but
        controls what data is stored; `columns` controls what is displayed
    </li>
    <li>
        an object corresponding to an ATTRS definition object, where you can
        <a href="datatable-recordtype.html">specify field validators, setters,
        getters, default values, etc.</a>.
    </li>
</ul>

<p>
    Alternately, you can just pass a prebuilt ModelList instance for the
    DataTable's `data` attribute, configured with whatever Model is appropriate.
</p>

<p>
    
    This new configuration option decouples DataTable from the data
    implementation, providing more opportunity for customization.
    For example, if you don't need any mutation events or attribute fanciness
    from your records&mdash;you just want it to render as fast as
    possible&mdash;you can configure it with a `recordType` class that pretends
    to be a Model, but is actually a much simpler object.
</p>

```
// Warning: crazy hack that probably shouldn't ever be used
// Some quacking will be needed for the various places where duck-typing is used
function DumbRecord(data) {
    this.data = data;
    this._id = 'record_' + DumbRecord._id++;
    this.lists = []; // quack
}

DumbRecord._id = 0;
DumbRecord.prototype = {
    _isYUIModel: 'quack',
    set: function () { /* quack */ },
    addTarget: function () { /* quack */ },
    getAttrs: function () { /* quack */ },

    get: function (name) {
        return name === 'clientId' ? this._id : this.data[name];
    },
    toJSON: function () { return this.data },
};

var table = new Y.DataTable({
    columns: [ ... ],
    data:  [ ... ],
    recordType: DumbRecord
}).render('#over-there');
```

<p>
    <strong>Note</strong>: This is an extreme case, and a hack, and shouldn't
    be necessary.  `recordType` is best used to build _on top of_ Model's
    infrastructure with classes that model your business objects.  There are
    several performance improvements planned for 3.6.0, making such hackery
    unnecessary even in those extreme cases.
</p>

<h4>Views for Rendering</h4>

<p>
    In keeping with the notion of configurable data storage, DataTable also
    delegates its rendering algorithms to View classes.  In 3.5.0, the basic,
    featureless DataTable has attributes `headerView`, `bodyView`, and
    `footerView`.  By default, `footerView` is unset, but `headerView` is set
    to `Y.DataTable.HeaderView`, and `bodyView` is set to
    `Y.DataTable.BodyView`.
</p>

<p>
    When a DataTable instance is `render()`ed, the only DOM content the Widget
    itself is responsible for is the `<table>` and its immediate children.  The
    rendering of the header content, footer content, and data rows is left to
    whatever View class is supplied to the respective attribute.
</p>

<p>
    The default Views attempt to match, and augment, the 3.4.1 feature set for
    header and cell customization, but with faster rendering algorithms.
    However, with the View itself now being configurable, that means that you
    can customize DataTable rendering from the column configuration level all
    the way to the View level, replacing the algorithm entirely.
</p>

```
// Create a custom subclass of View with a very simple rendering algorithm
var RowRowRowYourView = Y.Base.create('tableBody', Y.View, [], {
    render: function () {
        var tbody   = this.get('container'),
            rowData = this.get('modelList'),
            content = '';

        rowData.each(function (rowModel, index) {
            var stripe = index % 2 ? 'odd' : 'even',
                template = '<tr class="' + (index % 2 ? 'odd' : 'even') + '">' +
                    '<td>{username}</td><td>{first}</td><td>{last}</td>' +
                '</tr>';

            content += Y.Lang.sub(template, rowModel.toJSON());
        });

        tbody.setHTML(content);

        return this;
    }
});

var table = new Y.DataTable({
    data: [ ... ],
    columns: [ ... ],
    bodyView: RowRowRowYourView
}).render('#over-there');
```

<h3>Features as Class Extensions</h3>

<h3>New Rendering Algorithm</h3>


Rendering events
    render vs renderTable vs renderHeader, etc
    event to hand off responsibility to View


<h2>New Concepts</h2>

    MVC (really MVP) Widget

    Controller/View-Controller
        primary API lives on the instance
        some methods will relay to the view

    Instantiable namespace, pristeen Base
    Extensions auto-mixed

<h3>New Feature Architecture</h3>

<p>
    The downside of the name changes noted above is that the plugins that were
    reimplemented as class extensions suddenly disappear from the `Y.Plugin`
    namespace.  This can be confusing because `plug()` doesn't throw an error
    when a non-existent plugin class is passed as an argument.  But if your code
    is creating an instance of `Y.DataTable.Base` and plugging in
    `Y.Plugin.DataTableSort`, as of 3.5.0 it won't be sortable because the
    plugin doesn't exist, and sorting is added to `Y.DataTable`, not
    `Y.DataTable.Base`.  However, the fix is easy: change `Y.DataTable.Base` to
    `Y.DataTable`.  And you can get rid of the superfluous call to `plug(...)`
    as well.
</p>

<div class="yui3-g">
    <div class="yui3-u before">
        <h4 class="no-toc">Creates a non-sortable table in 3.5.0</h4>

        ```
        // DataTable.Base has no features, and ...
        var table = new Y.DataTable.Base({
            columns: [
                { key: "id" },
                { key: "name", sortable: true },
                { key: "price", sortable: true }
            ],
            data: [ ... ]
        });

        // the feature plugin no longer exists
        table.plug(Y.Plugin.DataTableSort);

        table.render('#back-then');
        ```
    </div>
    <div class="yui3-u after">
        <h4 class="no-toc">Fixed</h4>

        ```
        // Sorting is added to Y.DataTable by datatable-sort
        var table = new Y.DataTable({
            columns: [
                { key: "id" },
                { key: "name", sortable: true },
                { key: "price", sortable: true }
            ],
            data: [ ... ]
        });

        // now does nothing, but is harmless
        table.plug(Y.Plugin.DataTableSort);

        table.render('#here-and-now');
        ```
    </div>
</div>


<h2>New Features</h2>
mutable + sync layer access
column widths
100% width scrolling
table initially sorted
multi-column sorting
custom column sorting works
sortable: true/array
formatter rowClass
nodeFormatter
footer support


<h2>Experiments</h2>

Columns are simple objects
    removes the notion of a column instance, making changes to columns rely on
        table APIs
    In response to separation of concerns issues where a feature (sorting)
        required the Column class to host additional attributes.  A plugin
        requiring a class extension is confusing.
    May have been obviated by adhoc attribute support, added in 3.5.0 after
        the change was already in place.

Extensions auto-mixed


<h2>The way forward</h2>

gallery-preview module
view (aka tableView)
clean up/improve the configuration of Views
migrating features to new contract extension + view implementation model
pagination
progressive enhancement
cell/row editing
highlighting
row/cell selection
remote data love


<h3>When Will it Be Out of Beta?</h3>
Complicates beta marking because components are marked beta, not features

<h3>Questions?</h3>

forums, #yui, @ls_n. Shout out to the dialog in these places driving/validating
API decisions and helping prioritize the order of current and future feature
implementation.

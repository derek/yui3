<!DOCTYPE HTML>
<html>
    <head>
        <meta charset='utf-8'>
        <title>scrollview-base unit tests</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <link rel="stylesheet" href="../../../../build/cssreset/reset-min.css" type="text/css" media="screen" title="no title" charset="utf-8">
        <script src="../../../../build/yui/yui.js" type="text/javascript" charset="utf-8"></script>

        <style>
        	.horizontal {
                width:300px;
                height:200px;
                overflow:hidden;
                white-space: nowrap;
            }
            
            .horizontal li { 
                width:300px;
                height:200px;
                display: inline-block;
                background-image: -webkit-linear-gradient(left, red, white, blue);
                color:black;
                font-size:5em;
                opacity: 0.4;
                text-align:center;
            }

            .vertical li {
            	height: 100px;
                width:300px;
                color:black;
                font-size:5em;
                opacity: 0.4;
                text-align:center;
                background-image: -webkit-linear-gradient(top, green, white, blue);
            }
        </style>
        
        <script type="text/javascript" charset="utf-8">

        var s;
        var DURATION = 1;
        var SLOW_DURATION = 1000; // Neccesary to trigger certain lines

        YUI({
            filter: (window.location.search.match(/[?&]filter=([^&]+)/) || [])[1] || 'raw',
            coverage: ['scrollview-base']
        }).use('console', 'test', 'node-event-simulate', 'scrollview-base', function(Y) {

	        // Set up the page
	        var ASSERT = Y.Assert,
	            ARRAYASSERT = Y.ArrayAssert;

	        var myConsole = new Y.Console().render();
			
	        var testBasic = new Y.Test.Case({
	            name: "API Tests",
                _should: {
                    ignore: {

                    	// Ignore PhantomJS and IE
                        "Flick x should provide the correct reaction": Y.UA.phantomjs || Y.UA.ie,
                        "Move right on X should move the content right": Y.UA.phantomjs || Y.UA.ie,
                        "Move left on X should snap back": Y.UA.phantomjs || Y.UA.ie,
                        "Move down on Y should move the content at least that distance": Y.UA.phantomjs || Y.UA.ie,
                        "Move up on Y should bounce back": Y.UA.phantomjs || Y.UA.ie

                        // ** Selective disable/enable for easy testing purposes (SV test suite can take a little while to run all tests)
						// "Ensure rendering & initial state are correct": true,
						// "Ensure set('scrollX') works properly": true,
						// "Ensure the 'scrollEnd' event fires": true,
						// "Flick x should provide the correct reaction": true,
						// "lastScrolledAmt should be correct": true,
						// "Disabled flick should not scroll": true,
						// "Move right on X should move the content right": true,
						// "Move left on X should snap back": true,
						// "Move down on Y should move the content at least that distance": true,
						// "Move up on Y should bounce back": true,
						// "Disabled drag should not scroll": true,
						// "Disabled scrollview should not scroll": true,
						// "Widget resize should trigger heightChange": true,
                    }
                },

			    //---------------------------------------------
			    // Setup and tear down
			    //---------------------------------------------

	            setUp : function () {
	            	// console.log('setUp');
	            },

	            tearDown : function () {
	            	// console.log('tearDown');
	            	Y.one('#container').empty(true);
                },
			
				// ---------------------------------------------
				// Instantiation
				// ---------------------------------------------

// Initialization
				"Ensure initial state is correct": function() {
					var scrollview = renderNewScrollview(false),
						attrs = Y.ScrollView.ATTRS;

					// Loop through each ATTR and ensure its value matches the default to ensure any setters work properly.
					Y.Object.each(attrs, function (data, attr) {
						var val;

						if (data.value !== undefined) {
							val = data.value;
							if (Y.Lang.isObject(val)) {
								Y.ObjectAssert.areEqual(val, scrollview.get(attr));  // areEqual is deprecated, but still works
							}
							else {
								Y.Assert.areEqual(val, scrollview.get(attr));
							}
						}
					});
				},

				"Deprecated static values should set appropriate ATTRs": function() {

					Y.ScrollView.FRAME_STEP = 1;
					Y.ScrollView.SNAP_DURATION = 2;
					Y.ScrollView.SNAP_EASING = 3;
					Y.ScrollView.EASING = 4;
					Y.ScrollView.BOUNCE_RANGE = 5;

					var scrollview = renderNewScrollview(false);

					Y.Assert.areEqual(Y.ScrollView.FRAME_STEP, scrollview.get('frameDuration'));
					Y.Assert.areEqual(Y.ScrollView.SNAP_DURATION, scrollview.get('snapDuration'));
					Y.Assert.areEqual(Y.ScrollView.SNAP_EASING, scrollview.get('snapEasing'));
					Y.Assert.areEqual(Y.ScrollView.EASING, scrollview.get('easing'));
					Y.Assert.areEqual(Y.ScrollView.BOUNCE_RANGE, scrollview.get('bounceRange'));
				},

				"Ensure initial rendering is correct": function() {
					var scrollview = renderNewScrollview(false),
						bb = scrollview.get('boundingBox'),
						cb = scrollview.get('contentBox'),
						id = cb.get('id'),
						ul = cb.all('> ul'),
						li = cb.all('> ul > li');

					Y.Assert.areEqual(10, li.size());

					Y.Assert.isTrue(bb.hasClass('yui3-scrollview'), "BoundingBox does not contain class 'yui3-scrollview'");
					Y.Assert.isTrue(cb.hasClass('yui3-scrollview-content'), "ContentBox does not contain class 'yui3-scrollview-content'");
					// @TODO:  False-positive. This is having issues in IE7, fix
					Y.Assert.isTrue(bb.hasClass('yui3-scrollview-horiz'), "BoundingBox does not contain class 'yui3-scrollview-horiz'");
					
				},
// end Initialization


// Axis setters

				"Axis setters should work": function() {
					var scrollview = renderNewScrollview(false, {axis:'x'});
					
					Y.ObjectAssert.areEqual({x:true,y:false}, scrollview.get('axis'));
				},

				"Axis setters should work": function() {
					var scrollview = renderNewScrollview(false, {axis:'y'});

					Y.ObjectAssert.areEqual({x:false,y:true}, scrollview.get('axis'));
				},

				"Axis setters should work": function() {
					var scrollview = renderNewScrollview(false, {axis:'xy'});

					Y.ObjectAssert.areEqual({x:true,y:true}, scrollview.get('axis'));
				},

// end Axis setters

// Scroll{X/Y} setters
				"set('scrollX') to a positive distance should move it that distance": function() {
					var Test = this,
						scrollview = renderNewScrollview(false),
						distance = 20;

					// Assume it starts @ 0
					Y.Assert.areEqual(0, scrollview.get('scrollX'));
					scrollview.set('scrollX', distance);
					Y.Assert.areEqual(distance, scrollview.get('scrollX'));
				},
				
				"set('scrollX') above the max distance should move it the max X": function() {
					var Test = this,
						scrollview = renderNewScrollview(false),
						max = scrollview._maxScrollX;

					// Assume it starts @ 0
					Y.Assert.areEqual(0, scrollview.get('scrollX'));
					scrollview.set('scrollX', max+1);
					Y.Assert.areEqual(max, scrollview.get('scrollX'));
				},

				"set('scrollX') to a negative distance should not move it": function() {
					var Test = this,
						scrollview = renderNewScrollview(false),
						distance = -20;

					// Assume it starts @ 0
					Y.Assert.areEqual(0, scrollview.get('scrollX'));
					scrollview.set('scrollX', distance);
					Y.Assert.areEqual(0, scrollview.get('scrollX'));
				},				

				"set('scrollY') to a positive distance should move it that distance": function() {
					var Test = this,
						scrollview = renderNewScrollview(true),
						distance = 20;

					// Assume it starts @ 0
					Y.Assert.areEqual(0, scrollview.get('scrollY'));
					scrollview.set('scrollY', distance);
					Y.Assert.areEqual(distance, scrollview.get('scrollY'));
				},
				
				"set('scrollY') above the max distance should move it the max X": function() {
					var Test = this,
						scrollview = renderNewScrollview(true),
						max = scrollview._maxScrollY;

					// Assume it starts @ 0
					Y.Assert.areEqual(0, scrollview.get('scrollY'));
					scrollview.set('scrollY', max+1);
					Y.Assert.areEqual(max, scrollview.get('scrollY'));
				},

				"set('scrollY') to a negative distance should not move it": function() {
					var Test = this,
						scrollview = renderNewScrollview(true),
						distance = -20;

					// Assume it starts @ 0
					Y.Assert.areEqual(0, scrollview.get('scrollY'));
					scrollview.set('scrollY', distance);
					Y.Assert.areEqual(0, scrollview.get('scrollY'));
				},
// end Scroll{X/Y} setters


// scrollTo

				"scrollTo() on X should scroll": function() {
					var Test = this,
						scrollview = renderNewScrollview(false),
						distance = 500;
console.log(Y.Transition.useNative);
					scrollview.on('scrollEnd', function(){
						Test.resume(function(){
							Y.Assert.areEqual(distance, scrollview.get('scrollX'));
						})
					});

					scrollview.scrollTo(distance, null, DURATION);

					Test.wait(2000);
				},


// end scrollTo



// Events
				"Ensure the 'scrollEnd' event fires": function() {
					var Test = this,
						scrollview = renderNewScrollview(false),
						distance = scrollview._maxScrollX,
						eventsFired = 0;

					// Ensure scrollEnd fires
					scrollview.on('scrollEnd', function(){
						eventsFired++;
						Y.Assert.areEqual(distance, scrollview.get('scrollX'));
						Y.Assert.areEqual(0, scrollview.get('scrollY'));
						Y.Assert.areEqual(1, eventsFired);
					});

					scrollview.scrollTo(distance, 0, DURATION); // args = x, y, duration, easing
				},

				"Widget resize should trigger heightChange": function() {
					var Test = this,
						scrollview = renderNewScrollview(false),
						eventsFired = 0;

					// Ensure scrollEnd fires
					scrollview.after('heightChange', function(){
						Y.later(100, scrollview, function () {
							Test.resume(function () {
								eventsFired++;
								Y.Assert.areEqual(1, eventsFired);
							})
						})
					});

					Y.later(10, scrollview, function () {
						scrollview.set('height', 123);
					})

					Test.wait(2000);
				},
// end Events



// Properties
				"lastScrolledAmt should be correct": function() {
					
					var Test = this,
						scrollview = renderNewScrollview(false),
						distance = 500;

					scrollview.on('scrollEnd', function(){
						Test.resume(function(){
							Y.Assert.areEqual(distance, scrollview.lastScrolledAmt);
						})
					});

					scrollview.set('scrollX', distance, {duration: DURATION});

					Test.wait(2000);
				},
// end Properties


// Gesture: move
				"Move right on X should move the content right": function() {
					
					var Test = this,
						scrollview = renderNewScrollview(false),
						distance = 1000;
						
					scrollview.on('scrollEnd', function(){
						Test.resume(function(){
							if (scrollview.get('scrollX') >= 50) {
								Y.Assert.pass();
							}
							else {
								Y.Assert.fail();
							}
							Y.Assert.areEqual(0, scrollview.get('scrollY'));
						})
					});

					scrollview.get('contentBox').simulateGesture('move', {
                        path: {
                            xdist: -(distance)
                        },
                        duration: SLOW_DURATION
					});

					Test.wait(4000);
				},

				"Move left on X should snap back": function() {
					
					var Test = this,
						scrollview = renderNewScrollview(false),
						distance = 1000;
						
					scrollview.on('scrollEnd', function(){
						Test.resume(function(){
							Y.Assert.areEqual(0, scrollview.get('scrollY'));
							Y.Assert.areEqual(0, scrollview.get('scrollX'));
						})
					});

					scrollview.get('contentBox').simulateGesture('move', {
                        path: {
                            xdist: distance
                        },
                        duration: DURATION
					});

					Test.wait(2000);
				},

				"Move down on Y should move the content at least that distance": function() {
					
					var Test = this,
						scrollview = renderNewScrollview(true),
						distance = 500;
						
					scrollview.on('scrollEnd', function(){
						Test.resume(function(){
							if (scrollview.get('scrollY') >= distance) {
								Y.Assert.pass();
							}
							else {
								Y.Assert.fail();
							}
							Y.Assert.areEqual(0, scrollview.get('scrollX'));
						})
					});

					scrollview.get('contentBox').simulateGesture('move', {
                        path: {
                            ydist: -(distance)
                        },
                        duration: DURATION
					});

					Test.wait(2000);
				},

				"Move up on Y should bounce back": function() {
					
					var Test = this,
						scrollview = renderNewScrollview(true),
						distance = 500;

					scrollview.on('scrollEnd', function(){
						Test.resume(function(){
							Y.Assert.areEqual(0, scrollview.get('scrollY'));
							Y.Assert.areEqual(0, scrollview.get('scrollX'));
						})
					});

					scrollview.get('contentBox').simulateGesture('move', {
                        path: {
                            ydist: distance
                        },
                        duration: DURATION
					});

					Test.wait(2000);
				},
// Gesture: move



// Gesture: flick
				"Flick x should provide the correct reaction": function() {
					
					var Test = this,
						scrollview = renderNewScrollview(false);

					scrollview.on('scrollEnd', function(){
						Test.resume(function(){
							// depending on browser activity, scrollX won't always be exactly at the end (sometimes a few pixels shy), so we'll give it a large buffer
							(scrollview.get('scrollX') > 2000) ? Y.Assert.pass() : Y.Assert.fail();
							Y.Assert.areEqual(0, scrollview.get('scrollY'));
						});
					});

					scrollview.get('contentBox').simulateGesture('flick', {
						distance: -15000,
						axis: 'x'
					});

					Test.wait(4000);
				},

				"Disabled flick should not scroll": function() {
					
					var Test = this,
						scrollview = renderNewScrollview(false);

					scrollview.set('flick', false);
					scrollview.get('contentBox').simulateGesture('flick', {
						distance: -100,
						axis: 'x'
					});

					Y.later(200, this, function () {
						Test.resume(function(){
							Y.Assert.areEqual(0, scrollview.get('scrollX'));
						})
					});

					Test.wait(2000);
				},
// end Gesture:flick




// Disabled
				"Disabled drag should not scroll": function() {
					var Test = this,
						scrollview = renderNewScrollview(true),
						distance = 500;

					scrollview.set('drag', false);
					scrollview.get('contentBox').simulateGesture('move', {
                        path: {
                            ydist: distance
                        },
                        duration: SLOW_DURATION
					});

					Y.later(200, this, function () {
						Test.resume(function(){
							Y.Assert.areEqual(0, scrollview.get('scrollY'));
						})
					});

					Test.wait(2000);
				},

				"Disabled scrollview should not scroll": function() {
					var Test = this,
						scrollview = renderNewScrollview(false);

					scrollview.set('disabled', true);
					scrollview.scrollTo(500, null);
					Y.later(100, this, function () {
						Test.resume(function () {
							Y.Assert.areEqual(0, scrollview.get('scrollX'));
						})
					});
					Test.wait(2000);
				},

				"Disabled scrollview should not move on gesture": function() {
					var Test = this,
						scrollview = renderNewScrollview(false),
						distance = 100;

					scrollview.set('disabled', true);

					scrollview.get('contentBox').simulateGesture('move', {
                        path: {
                            ydist: -(distance)
                        },
                        duration: DURATION
					});

					Y.later(100, this, function () {
						Test.resume(function () {
							Y.Assert.areEqual(0, scrollview.get('scrollX'));
						})
					});

					Test.wait(2000);
				}
// end Disabled





/* These tests are not possible until mousewheel simulation is available

				"Mousewheel event provides the correct reaction": function() {
					var Test = this,
						scrollview = renderNewScrollview(true);

					scrollview.get('contentBox').simulate('mousewheel');
					Y.Assert.isTrue(true, "is true");
				}
*/

/*
				Additional tests
				- Don't scroll Y if a X axis
				- Don't scroll X if a Y axis
				- sv._prevent.start
				- sv._prevent.end
				- Flick while already executing a flick
				- Forced axis vs auto-detection
				- Make sure scrollEnd only fires once
				- setScroll after disabling
				- Flick while flicking
				- swipe to OOB
*/
	        });

	        var suite = new Y.Test.Suite("Scrollview: Base");
	        suite.add(testBasic);

	        Y.Test.Runner.add(suite);
	        Y.Test.Runner.run();

			function renderNewScrollview (vertical, config) {

				var config = config || {},
					guid = Y.guid(),
					html,
					scrollview,
					widgetClass;
					            
	            config.srcNode = '#' + guid;

	            if (vertical) {
	            	config.height = "100px";
	            	widgetClass = 'vertical';
	            }
	            else {
	            	config.width = "300px";
	            	widgetClass = 'horizontal';
	            }

				html = "<div class='" + widgetClass + "'><div id='" + guid + "'><ul><li>a</li><li>b</li><li>c</li><li>e</li><li>f</li><li>g</li><li>h</li><li>i</li><li>j</li><li>k</li></ul></div></div>",
	            Y.one('#container').append(html);

				scrollview = new Y.ScrollView(config);
				scrollview.render();

				return scrollview;
			}

        });
        </script>
    </head>

    <body class="yui3-skin-sam">
        
        <div id="container"></div>

    </body>
</html>
